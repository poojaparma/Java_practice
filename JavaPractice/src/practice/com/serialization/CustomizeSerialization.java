package practice.com.serialization;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Calendar;
import java.util.Date;

public class CustomizeSerialization {
	

	/*
	 * How to customize the default protocol? MMmmmm.. Now its getting more
	 * interesting. Lets say, you need to perform some specific operations in
	 * the constructor when you are instantiating the class but you cant perform
	 * those operations when you deserialize the object because constructor wont
	 * be called when an object is de-serialized. Here we are restoring an
	 * object but not reconstructing an object. Then how will you call or
	 * perform those operations when you desrialize the object? Well, you have a
	 * way here and its simple too. You can enhance the normal process by
	 * providing two methods inside your serializable class. Those methods are:
	 * 
	 * private void writeObject(ObjectOutputStream out) throws IOException;
	 * 
	 * private void readObject(ObjectInputStream in) throws IOException,
	 * ClassNotFoundException;
	 */
	/*Notice that both methods are declared private and 
	 * ofcourse they must be declared private, 
	 * proving that neither method is inherited and overridden or overloaded. 
	The trick here is that the virtual machine will automatically check to see 
	if either method is declared during the corresponding method call.
	The virtual machine can call private methods of your class whenever it wants but no other objects can. 
	Thus, the integrity of the class is maintained and the serialization protocol can continue to work as normal.*/

	    private Date currentTime;

	    public CustomizeSerialization() {
	        calculateCurrentTime();
	    }

	    public Date getCurrentTime() {
	        return currentTime;
	    }

	    private void calculateCurrentTime(){
	        currentTime = Calendar.getInstance().getTime();
	    }

	 /*   private void writeObject(ObjectOutputStream out) throws IOException {
	        out.defaultWriteObject();
	    }

	    private void readObject(ObjectInputStream in) 
		    throws IOException, ClassNotFoundException{

	        // our "pseudo-constructor"
	        in.defaultReadObject();
	        // now perfrom same operation you need to do in constructor
	        calculateCurrentTime();
	    }*/
	    /*   Ooops.
	   I mentioned earlier that for a class to be serializable either the class should implement "Serializable" 
	    interface or one of its super class should implement "Serializable" interface. 
	    Now what if you dont want to serialize one of the sub class of a serializable class? 
	    		You have a way here tooo. To stop the automatic serialization, you can once again use 
	    		the private methods to just throw the NotSerializableException in your class.*/


	    		/*private void writeObject(ObjectOutputStream out) throws IOException{

	    		    throw new NotSerializableException("Dont Serialize");
	    		}

	    		private void readObject(ObjectInputStream in) throws IOException{

	    		    throw new NotSerializableException("Dont Serialize");
	    		}*/
	    
	/*
	 * Also the static fields are not serialized. Actually there is no point in
	 * serializing static fields as static fields do not represent object state
	 * but represent class state and it can be modified by any other object.
	 * Lets assume that you have serialized a static field and its value and
	 * before deserialization of the object, the static field value is changed
	 * by some other object. Now the static field value that is
	 * serialized/stored is no more valid. Hence it make no point in serializing
	 * the static field.
	 */
	/*
	 * What happens to inner classes? We forgot all about it.
	 * 
	 * Yes, you can serialize inner classes by implementing the Serializable
	 * interface but it has some problems. Inner classes (declared in a
	 * non-static context) will always contain implicit references to their
	 * enclosing classes and these references are always non-transient. So,
	 * while object serialization process of inner classes, the enclosing
	 * classes will also be serialized. Now the problem is that the synthetic
	 * fields generated by Java compilers to implement inner classes are pretty
	 * much implementation dependent and hence we may face compatibility issues
	 * while deserialization on a different platform having a .class file
	 * generated by a different Java compiler. The default serialVerionUID may
	 * also be different in such cases. Not only this, the names assigned to the
	 * local and anonymous inner classes are also implementation dependent.
	 * Thus, we see that object serialization of inner classes may pose some
	 * unavoidable compatibility issues and hence the serialization of inner
	 * classes is strongly discouraged.
	 */

}
